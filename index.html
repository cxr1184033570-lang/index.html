<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>音符粒子 - 交互散开 + 声音</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body, html {
      width:100%; height:100%;
      overflow:hidden;
      background:#000;
      touch-action:none;
    }
    canvas { display:block; }
  </style>
</head>
<body>

<canvas id="c"></canvas>

<script>
// ==================== 主代码 ====================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

let particles = [];
let pointer = { x: null, y: null, active: false };

// 全屏适应
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// 指针（鼠标/触控）事件
function updatePointer(e) {
  const touch = e.touches ? e.touches[0] : e;
  pointer.x = touch ? touch.clientX : e.clientX;
  pointer.y = touch ? touch.clientY : e.clientY;
  pointer.active = true;
}

window.addEventListener('mousemove', updatePointer);
window.addEventListener('touchstart', (e) => { updatePointer(e); playNote(); });
window.addEventListener('touchmove', (e) => {
  e.preventDefault();
  updatePointer(e);
  if (Math.random() < 0.12) playNote(); // 滑动时适度触发声音
});
window.addEventListener('touchend', () => { pointer.active = false; });
window.addEventListener('mouseleave', () => { pointer.active = false; });

// ==================== 悦耳音符声音 ====================
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const scale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]; // C4~C5

function playNote() {
  if (audioCtx.state === 'suspended') audioCtx.resume();
  
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  
  osc.type = 'sine';           // 正弦波 → 柔和悦耳
  osc.frequency.value = scale[Math.floor(Math.random() * scale.length)];
  
  gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4); // 0.4秒淡出
  
  osc.start();
  osc.stop(audioCtx.currentTime + 0.45);
}

// ==================== 粒子类 ====================
class Particle {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * canvas.width;
    this.y = Math.random() * canvas.height;
    this.baseX = this.x;
    this.baseY = this.y;
    this.size = Math.random() * 2 + 1;          // 1~3
    this.vx = (Math.random() - 0.5) * 0.3;      // 极慢漂移初速
    this.vy = (Math.random() - 0.5) * 0.3;
    this.phase = Math.random() * Math.PI * 2;   // 用于缓慢漂移的相位
  }
  
  update() {
    // 非交互：极缓慢有机漂移（sin/cos 模拟风/呼吸感）
    this.phase += 0.002;
    this.x += this.vx + Math.sin(this.phase + this.y * 0.01) * 0.15;
    this.y += this.vy + Math.cos(this.phase + this.x * 0.008) * 0.12;
    
    // 轻微边界回弹（不严格，允许轻微溢出再回）
    if (this.x < -20 || this.x > canvas.width + 20)  this.vx *= -0.8;
    if (this.y < -20 || this.y > canvas.height + 20) this.vy *= -0.8;
    
    // 与指针交互
    if (pointer.active && pointer.x != null) {
      const dx = pointer.x - this.x;
      const dy = pointer.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if (dist < 140) {  // 影响半径
        const force = (140 - dist) / 140;
        const fx = dx / dist * force * 3.5;
        const fy = dy / dist * force * 3.5;
        
        this.x -= fx;
        this.y -= fy;
        
        // 交互中播放声音（低概率，避免噪音）
        if (Math.random() < 0.015) playNote();
      }
    }
    
    // 慢慢回到原始位置（弹性）
    this.x += (this.baseX - this.x) * 0.015;
    this.y += (this.baseY - this.y) * 0.015;
  }
  
  draw() {
    const dx = pointer.x - this.x;
    const dy = pointer.y - this.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const interacting = pointer.active && dist < 140;
    
    ctx.fillStyle = interacting 
      ? 'rgba(220, 240, 255, 0.9)'   // 交互时亮银蓝
      : 'rgba(200, 220, 240, 0.7)';  // 平时淡银灰蓝
    
    ctx.beginPath();
    
    if (interacting) {
      // 简易音符形状：椭圆头 + 竖杆 + 小旗
      const angle = Math.atan2(dy, dx) + Math.PI/2; // 朝向指针方向
      const headX = this.x;
      const headY = this.y;
      
      // 头部椭圆
      ctx.ellipse(headX, headY, this.size*1.4, this.size*0.9, angle, 0, Math.PI*2);
      // 竖杆
      ctx.moveTo(headX + Math.cos(angle)*this.size*1.2, headY + Math.sin(angle)*this.size*1.2);
      ctx.lineTo(headX + Math.cos(angle)*this.size*1.2, headY + Math.sin(angle)*this.size*-4);
      // 小旗（贝塞尔曲线）
      ctx.moveTo(headX + Math.cos(angle)*this.size*1.2, headY + Math.sin(angle)*this.size*-4);
      ctx.quadraticCurveTo(
        headX + Math.cos(angle + 0.8)*this.size*4,
        headY + Math.sin(angle + 0.8)*this.size*-3.5,
        headX + Math.cos(angle)*this.size*1.2,
        headY + Math.sin(angle)*this.size*-2.2
      );
    } else {
      // 非交互：普通圆点
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    }
    
    ctx.fill();
  }
}

// 初始化粒子（根据屏幕密度）
function initParticles() {
  particles = [];
  const count = Math.floor((canvas.width * canvas.height) / 1800); // 密集但不卡
  for (let i = 0; i < count; i++) {
    particles.push(new Particle());
  }
}
initParticles();
window.addEventListener('resize', initParticles);

// 动画循环
function animate() {
  ctx.fillStyle = 'rgba(0,0,0,0.08)'; // 轻微拖尾感
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  particles.forEach(p => {
    p.update();
    p.draw();
  });
  
  requestAnimationFrame(animate);
}
animate();

</script>
</body>
</html>